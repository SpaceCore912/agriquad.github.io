# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ft0R_t7mHOiHZF_UjbZ0egWrrCbZypb6

# reading
"""

import pandas as pd
import numpy as np

crops_import=pd.read_excel("/content/usda_fas_gats_imports_general.xlsx")

crops_import

# prompt: Using dataframe crops_import: to make the sum of values of the date as the amount of mony

# Create a new column 'Total_Import' to store the sum of import values for each Partner across all years.
crops_import['Total_Import'] = crops_import[[2016, 2017, 2018, 2019, 2020, 2021]].sum(axis=1)
crops_import

crops_export=pd.read_excel("/content/usda_fas_gats_exports.xlsx")

crops_export
# Create a new column 'Total_Import' to store the sum of import values for each Partner across all years.
crops_export['Total_export'] = crops_export[[2016, 2017, 2018, 2019, 2020, 2021]].sum(axis=1)
crops_export

disaster = pd.read_excel("/content/emdat-country-profiles_2024_09_30.xlsx")
disaster

corn = pd.read_excel("/content/CornCostReturn.xlsx",sheet_name="Data sheet (machine readable)")
corn

crop=pd.read_csv("/content/7a8590c1-c97e-4267-af83-e9e61ad4d578 (2).csv")
crop



"""# cleaning

"""

# cleaning

crops_import.head(5)
crops_import.info()
crops_import.dropna()
crops_import.columns


crops_import.describe()

# def to unique values of coulmn
def unique_values(data,coulmn):

           print(data[coulmn].drop_duplicates().unique())

# see the unique value of name
unique_values(crops_import,"Partner")

crops_import["Partner"]=crops_import["Partner"].replace(["Leeward-Windward Islands(*)","Australia(*)","Germany(*)","Ethiopia(*)","France(*)"],["Leeward-Windward Islands","Australia","Germany","Ethiopia","France"])

# see the unique value of name
unique_values(crops_import,"Partner")

crops_export.info()
crops_export.head(5)
crops_export.dropna()
crops_export.columns

crops_export.describe()

# see the unique value of name
unique_values(crops_export,"Partner")

replace_dict = {
       "Leeward-Windward Islands(*)": "Leeward-Windward Islands",
       "Australia(*)": "Australia",
       "Germany(*)": "Germany",
       "Ethiopia(*)": "Ethiopia",
       "France(*)": "France",
       "Belgium-Luxembourg(*)": "Belgium-Luxembourg",
       "French Pacific Islands(*)": "French Pacific Islands",
       "Israel(*)": "Israel",
       "Italy(*)": "Italy",
       "Netherlands Antilles(*)": "Netherlands Antilles",
       "Norway(*)": "Norway",
       "New Zealand(*)": "New Zealand",
       "Switzerland(*)": "Switzerland"

   }

crops_export["Partner"] = crops_export["Partner"].replace(replace_dict)

#see the unique value of name
unique_values(crops_export,"Partner")

crops_export.describe()

crops_export.describe()
crops_export.info()

disaster.info()

disaster.describe()

disaster.dropna()

disaster_new=disaster.loc[disaster['Disaster Group'] == 'Natural']

disaster_new

unique_values(disaster_new,"Disaster Type")

unique_values(disaster_new,"Total Events")

disaster_drought=disaster_new.loc[disaster_new["Disaster Type"] == "Drought"]

disaster_flood=disaster_new.loc[disaster_new["Disaster Type"] == "Flood"]
disaster_storm=disaster_new.loc[disaster_new["Disaster Type"] == "Storm"]
disaster_wildfire=disaster_new.loc[disaster_new["Disaster Type"] == "Wildfire"]
disaster_Extreme_temperature = disaster_new.loc[disaster_new["Disaster Type"] == "Extreme temperature"]
disaster_Earthquake = disaster_new.loc[disaster_new["Disaster Type"] == "Earthquake"]
disaster_Volcanic_activity = disaster_new.loc[disaster_new["Disaster Type"] == "Volcanic activity"]


disaster_Glacial_lake_outburst_flood = disaster_new.loc[disaster_new["Disaster Type"] == "Glacial lake outburst flood"]
disaster_Mass_movement_dry= disaster_new.loc[disaster_new["Disaster Type"] == "Mass movement (dry)"]
disaster_Mass_movement_wet = disaster_new.loc[disaster_new["Disaster Type"] == "Mass movement (wet)"]
disaster_Infestation= disaster_new.loc[disaster_new["Disaster Type"] == "Infestation"]
disaster_Impact= disaster_new.loc[disaster_new["Disaster Type"] == "Impact"]

corn.describe()

corn.info()
corn.dropna()

unique_values(corn,"Category")

unique_values(corn,"Item")

unique_values(corn,"Item2")

unique_values(corn,"Units")

crop.info()
crop.describe()
crop.dropna()

unique_values(crop,"INDICATOR")

unique_values(crop,"SUBJECT")

unique_values(crop,"MEASURE")

unique_values(crop,"TIME")

import matplotlib.pyplot as plt

def events_over_time(data, x, y, title):
  """
  Plots events over time for each country.

  Args:
    data: DataFrame containing the data.
    x: Column name for the x-axis (e.g., 'Year').
    y: Column name for the y-axis (e.g., 'Total Events').
    title: Title of the plot.
  """
  plt.figure(figsize=(10, 6))
  for country in data['Country'].unique():
    country_data = data[data['Country'] == country]
    plt.plot(country_data[x], country_data[y], marker='o', label=country)
  plt.xlabel(x)
  plt.ylabel(y)
  plt.title(title)
  plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
  plt.show()

import plotly.express as px
import pandas as pd


def plotly_choropleth_map(data, title):
  """
  Creates a choropleth map to visualize drought events with years in descending order.

  Args:
    data: DataFrame containing the data.
    title: Title of the map.
  """
  data = data.sort_values(by=['Country', 'Year'])

  # Convert 'Total Events' column to numeric type
  data['Total Events'] = pd.to_numeric(data['Total Events'])

  data['Cumulative Events'] = data.groupby('Country')['Total Events'].cumsum()
  data = data[['Country', 'Year', 'Cumulative Events']].drop_duplicates(subset=['Country', 'Year'], keep='last')

  fig = px.choropleth(data, locations="Country", locationmode='country names',
                     color="Cumulative Events", hover_name="Country",
                     animation_frame="Year",
                     color_continuous_scale="Reds", title=title)
  fig.show()

"""# disaster"""

plotly_choropleth_map(disaster_drought, "Drought Events Over Time ")

plotly_choropleth_map(disaster_flood, "flood Events Over Time ")

plotly_choropleth_map(disaster_storm, "storm Events Over Time ")

plotly_choropleth_map(disaster_wildfire, "wildfire Events Over Time ")

plotly_choropleth_map(disaster_Extreme_temperature, "Extreme temperature Events Over Time ")

plotly_choropleth_map(disaster_Earthquake, "Earthquake Events Over Time ")

plotly_choropleth_map(disaster_Volcanic_activity, "Volcanic activity Events Over Time ")

plotly_choropleth_map(disaster_Glacial_lake_outburst_flood, "Glacial lake outburst flood Events Over Time ")

plotly_choropleth_map(disaster_Mass_movement_dry, "Mass movement(dry) Events Over Time ")

plotly_choropleth_map(disaster_Mass_movement_wet, "disaster Mass movement(wet) Events Over Time ")

plotly_choropleth_map(disaster_Infestation, "Infestation Events Over Time ")

plotly_choropleth_map(disaster_Impact, "Impact Events Over Time ")

max_total_import_row = crops_import.loc[crops_import['Total_Import'].idxmax()]
print(max_total_import_row)

max_total_export_row = crops_export.loc[crops_export['Total_export'].idxmax()]
print(max_total_export_row)



"""# soebeans import export

"""

def bar(data,categorical,numerical,Title):
    data.groupby(categorical)[numerical].median().plot( kind="bar",figsize=(10,10))
    plt.xlabel("countries")
    plt.ylabel("Median " + numerical)
    plt.title(Title)
    plt.show()
    plt.savefig('seabeans.png')

bar(crops_import,"Partner","Total_Import","soebeans import")



import matplotlib.pyplot as plt

def three_bar(data,x,y,title):
# Group by 'Country' and sum 'Total Events'
  grouped = data.groupby(x)[y].median().reset_index()

# Split the data into three parts
  num_countries = len(grouped)
  third = num_countries // 3

# Calculate the split indices
  split_idx_1 = third
  split_idx_2 = 2 * third

# Split the DataFrame
  df_part1 = grouped.iloc[:split_idx_1]
  df_part2 = grouped.iloc[split_idx_1:split_idx_2]
  df_part3 = grouped.iloc[split_idx_2:]

# Create three subplots
  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 6))

# Plot the first part as a bar chart
  ax1.bar(df_part1[x], df_part1[y])
  ax1.set_xlabel("Countries")
  ax1.set_ylabel("Average "+y)
  ax1.set_title(title)
  ax1.tick_params(axis='x', rotation=90)

# Plot the second part as a bar chart
  ax2.bar(df_part2[x], df_part2[y])
  ax2.set_xlabel("Countries")
  ax2.set_ylabel("Average "+y)
  ax2.set_title(title)
  ax2.tick_params(axis='x', rotation=90)

  ax3.bar(df_part3[x], df_part3[y])
  ax3.set_xlabel("Countries")
  ax3.set_ylabel("Average "+y)
  ax3.set_title(title)
  ax3.tick_params(axis='x', rotation=90)

# Adjust spacing between subplots
  plt.tight_layout()

# Show the plot
  plt.show()
three_bar(crops_export,"Partner","Total_export","soebeans export")

"""# corn cost and return

"""

import seaborn as sns
import matplotlib.pyplot as plt
unique_units = corn['Units'].unique()


for unit in unique_units:
  df_filtered = corn[corn['Units'] == unit]
  plt.figure(figsize=(10, 6))
  sns.barplot(x='Category', y='Value', data=df_filtered)
  plt.xlabel("Category")
  plt.ylabel("Value (" + unit + ")")
  plt.title("Corn Data for " + unit)
  plt.show()



grouped = corn.groupby(['Units', 'Item'])['Value'].sum().reset_index()

for unit in grouped['Units'].unique():
  unit_data = grouped[grouped['Units'] == unit]
  plt.figure(figsize=(10, 6))
  plt.bar(unit_data['Item'], unit_data['Value'])
  plt.xlabel("Item")
  plt.ylabel("Value")
  plt.title(f'Corn Data for {unit}')
  plt.xticks(rotation=90)
  plt.show()

"""# corp

"""

import matplotlib.pyplot as plt

measures = crop["MEASURE"].unique().tolist()

for measure in measures:
  df_filtered = crop[crop['MEASURE'] == measure]
  grouped = df_filtered.groupby(['TIME', 'SUBJECT'])['Value'].sum().reset_index()
  # Create a dictionary to store data for each subject
  subjects = {}
  for subject in grouped['SUBJECT'].unique():
    subjects[subject] = grouped[grouped['SUBJECT'] == subject]

  plt.figure(figsize=(10, 6))

  # Create grouped bar chart
  width = 0.15
  x = range(len(grouped['TIME'].unique()))
  for i, subject in enumerate(subjects):
    plt.bar([pos + i * width for pos in x], subjects[subject]['Value'], width, label=subject)

  # Set x-axis labels to years
  plt.xticks([pos + 1.5 * width for pos in x], grouped['TIME'].unique())
  plt.xlabel("Year")
  plt.ylabel("Value")
  plt.title(f'Crop Values for Measure : {measure} using cropyeild as indicator ')
  plt.xticks(rotation=90)
  plt.legend()
  plt.show()

"""# dash"""

!pip install dash

import dash
from dash import dcc
from dash import html
import pandas as pd
import plotly.express as px

# Load the data
data = disaster_new

# Create the Dash app
app = dash.Dash(__name__)

# Define the layout
app.layout = html.Div([
    html.H1('Disaster Data Visualization'),
    dcc.Dropdown(
        id='country-dropdown',
        options=[{'label': country, 'value': country} for country in data['Country'].unique()],
        value='United States of America'  # Default value
    ),
    dcc.Dropdown(
        id='disaster-type-dropdown',
        options=[{'label': disaster_type, 'value': disaster_type} for disaster_type in data['Disaster Type'].unique()],
        value='Flood'  # Default value
    ),
    dcc.Graph(id='event-chart'),
    dcc.Graph(id='affected-chart'),
    dcc.Graph(id='damage-chart'),
    dcc.Graph(id='map')
])

# Callback functions to update charts based on dropdown selections
@app.callback(
    [dash.Output('event-chart', 'figure'),
     dash.Output('affected-chart', 'figure'),
     dash.Output('damage-chart', 'figure'),
     dash.Output('map', 'figure')],
    [dash.Input('country-dropdown', 'value'),
     dash.Input('disaster-type-dropdown', 'value')]
)
def update_charts(country, disaster_type):
    # Filter data based on selected criteria
    filtered_data = data[(data['Country'] == country) & (data['Disaster Type'] == disaster_type)]

    # Create charts
    fig1 = px.bar(filtered_data, x='Year', y='Total Events', title='Total Events Over Time')
    fig2 = px.line(filtered_data, x='Year', y='Total Affected', title='Total Affected Over Time')
    fig3 = px.bar(filtered_data, x='Year', y='Total Damage (USD, original)', title='Total Damage Over Time')
    fig4 = px.choropleth(filtered_data, locations='ISO', color='Total Affected', hover_name='Country',
                        color_continuous_scale='Viridis', title='Total Affected People by Country')

    return fig1, fig2, fig3, fig4

if __name__ == '__main__':
    app.run_server(debug=True)



def bar(data,categorical,numerical,Title):
    data.groupby(categorical)[numerical].mean().plot( kind="bar",figsize=(10,10))
    plt.xlabel("countryies")
    plt.ylabel(numerical)
    plt.title(Title)
    plt.show()

bar(crops_import,"Partner","Total_Import","soebeans import")



!pip install ipywidgets
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets

def show_visualizations(visualization_type):
  if visualization_type == 'drought':
    plotly_choropleth_map(disaster_drought, "Drought Events Over Time ")
  elif visualization_type == 'flood':
    plotly_choropleth_map(disaster_flood, "flood Events Over Time ")
  # Add more conditions for other visualization types

interact(show_visualizations, visualization_type=['drought', 'flood', 'storm', 'wildfire']) # Add other options as needed